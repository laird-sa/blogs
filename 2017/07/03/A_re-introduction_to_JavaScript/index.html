<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>重新介绍 JavaScript（JS全面系列教程） | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="引言为什么会有这一篇“重新介绍”呢？因为 JavaScript 堪称世界上被人误解最深的编程语言。虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 JavaScript 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 JavaScript 就尤有必要。">
<meta property="og:type" content="article">
<meta property="og:title" content="重新介绍 JavaScript（JS全面系列教程）">
<meta property="og:url" content="http://example.com/2017/07/03/A_re-introduction_to_JavaScript/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="引言为什么会有这一篇“重新介绍”呢？因为 JavaScript 堪称世界上被人误解最深的编程语言。虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 JavaScript 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 JavaScript 就尤有必要。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://badge.juejin.im/entry/595a40785188250d92086765/likes.svg?style=flat-square">
<meta property="article:published_time" content="2017-07-03T10:51:21.000Z">
<meta property="article:modified_time" content="2024-01-20T12:06:05.083Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="Function">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://badge.juejin.im/entry/595a40785188250d92086765/likes.svg?style=flat-square">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-A_re-introduction_to_JavaScript" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/07/03/A_re-introduction_to_JavaScript/" class="article-date">
  <time class="dt-published" datetime="2017-07-03T10:51:21.000Z" itemprop="datePublished">2017-07-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      重新介绍 JavaScript（JS全面系列教程）
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>为什么会有这一篇“重新介绍”呢？因为 <code>JavaScript</code> 堪称世界上被人误解最深的编程语言。虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 <code>JavaScript</code> 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 <code>JavaScript</code> 就尤有必要。</p>
<span id="more"></span>

<p>先从这门语言的历史谈起是有必要的。在<code>1995</code> 年 <code>Netscape</code> 一位名为 Brendan Eich 的工程师创造了 <code>JavaScript</code>，随后在 <code>1996</code> 年初，<code>JavaScript</code> 首先被应用于 <code>Netscape</code> 2 浏览器上。最初的 <code>JavaScript</code> 名为 <code>LiveScript</code>，后来因为 <code>Sun Microsystem</code> 的 <code>Java</code> 语言的兴起和广泛使用，<code>Netscape</code> 出于宣传和推广的考虑，将它的名字从最初的 LiveScript 更改为 <code>JavaScript</code>——尽管两者之间并没有什么共同点。这便是之后混淆产生的根源。</p>
<p>几个月后，<code>Microsoft</code> 随着 <code>IE 3</code> 推出了一个与之基本兼容的语言 <code>JScript</code>。又几个月后，<code>Netscape</code> 将 <code>JavaScript</code> 提交至 <code>Ecma International</code>（一个欧洲标准化组织）， <code>ECMAScript</code> 标准第一版便在 <code>1997</code> 年诞生了，随后在 <code>1999</code> 年以 <code>ECMAScript</code> 第三版的形式进行了更新，从那之后这个标准没有发生过大的改动。由于委员会在语言特性的讨论上发生分歧，<code>ECMAScript</code> 第四版尚未推出便被废除，但随后于 <code>2009</code> 年 <code>12</code> 月发布的 <code>ECMAScript</code> 第五版引入了第四版草案加入的许多特性。第六版标准已经于<code>2015</code>年六月发布。</p>
<p>注意： 为熟悉起见，从这里开始我们将用 “<code>JavaScript</code>” 替代 <code>ECMAScript</code> 。<br>与大多数编程语言不同，<code>JavaScript</code> 没有输入或输出的概念。它是一个在宿主环境（<code>host environment</code>）下运行的脚本语言，任何与外界沟通的机制都是由宿主环境提供的。浏览器是最常见的宿主环境，但在非常多的其他程序中也包含 <code>JavaScript</code> 解释器，如 <code>Adobe Acrobat</code>、<code>Photoshop</code>、<code>SVG</code> 图像、<code>Yahoo!</code> 的 <code>Widget</code> 引擎，以及 <code>Node.js</code> 之类的服务器端环境。<code>JavaScript</code> 的实际应用远不止这些，除此之外还有 <code>NoSQL</code> 数据库（如开源的 <code>Apache CouchDB</code>）、嵌入式计算机，以及包括 <code>GNOME</code> （注：<code>GNU/Linux</code> 上最流行的 <code>GUI</code> 之一）在内的桌面环境等等。</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>JavaScript</code> 是一种面向对象的动态语言，它包含类型、运算符、标准内置（ <code>built-in</code>）对象和方法。它的语法来源于 <code>Java</code> 和 <code>C</code>，所以这两种语言的许多语法特性同样适用于 <code>JavaScript</code>。需要注意的一个主要区别是 <code>JavaScript</code> 不支持类，类这一概念在 <code>JavaScript</code> 通过对象原型（<code>object prototype</code>）得到延续（有关 <code>ES6</code> 类的内容参考这里<code>Classes</code>）。另一个主要区别是 <code>JavaScript</code> 中的函数也是对象，<code>JavaScript</code> 允许函数在包含可执行代码的同时，能像其他对象一样被传递。</p>
<p>先从任何编程语言都不可缺少的组成部分——“类型”开始。<code>JavaScript</code> 程序可以修改值（<code>value</code>），这些值都有各自的类型。<code>JavaScript</code> 中的类型包括：</p>
<ul>
<li><code>Number</code>（数字）</li>
<li><code>String</code>（字符串）</li>
<li><code>Boolean</code>（布尔）</li>
<li><code>Function</code>（函数）</li>
<li><code>Object</code>（对象）</li>
<li><code>Symbol</code> (第六版新增)</li>
</ul>
<p>…哦，还有看上去有些…奇怪的 <code>undefined</code>（未定义）类型和 <code>null</code>（空）类型。此外还有<code>Array</code>（数组）类型，以及分别用于表示日期和正则表达式的 <code>Date</code>（日期）和 <code>RegExp</code>（正则表达式），这三种类型都是特殊的对象。严格意义上说，<code>Function</code>（函数）也是一种特殊的对象。所以准确来说，<code>JavaScript</code> 中的类型应该包括这些：</p>
<ul>
<li><code>Number</code>（数字）</li>
<li><code>String</code>（字符串）</li>
<li><code>Boolean</code>（布尔）</li>
<li><code>Symbol</code>（符号）（第六版新增）</li>
<li><code>Object</code>（对象）</li>
<li><code>Function</code>（函数）</li>
<li><code>Array</code>（数组）</li>
<li><code>Date</code>（日期）</li>
<li><code>RegExp</code>（正则表达式）</li>
<li><code>Null</code>（空）</li>
<li><code>Undefined</code>（未定义）</li>
<li><code>JavaScript</code> 还有一种内置<code>Error</code>（错误）类型，这个会在之后的介绍中提到；现在我们先讨论下上面这些类型。</li>
</ul>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>根据语言规范，<code>JavaScript</code> 采用“<code>IEEE 754</code> 标准定义的双精度<code>64</code>位格式”（”<code>double-precision 64-bit format IEEE 754 values</code>“）表示数字。据此我们能得到一个有趣的结论，和其他编程语言（如 <code>C</code> 和 <code>Java</code>）不同，<code>JavaScript</code> 不区分整数值和浮点数值，所有数字在 <code>JavaScript</code> 中均用浮点数值表示，所以在进行数字运算的时候要特别注意。看看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> = <span class="number">0.30000000000000004</span></span><br></pre></td></tr></table></figure>

<p>在具体实现时，整数值通常被视为<code>32</code>位整型变量，在个别实现（如某些浏览器）中也以<code>32</code>位整型变量的形式进行存储，直到它被用于执行某些<code>32</code>位整型不支持的操作，这是为了便于进行位操作。</p>
<p><code>JavaScript</code> 支持标准的算术运算符，包括加法、减法、取模（或取余）等等。还有一个之前没有提及的内置对象 <code>Math</code>（数学对象），用以处理更多的高级数学函数和常数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">sin</span>(<span class="number">3.5</span>);</span><br><span class="line"><span class="keyword">var</span> d = <span class="title class_">Math</span>.<span class="property">PI</span> * (r + r);</span><br></pre></td></tr></table></figure>

<p>你可以使用内置函数 <code>parseInt()</code> 将字符串转换为整型。该函数的第二个参数表示字符串所表示数字的基（进制）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;123&quot;</span>, <span class="number">10</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;010&quot;</span>, <span class="number">10</span>); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p>如果调用时没有提供第二个参数（字符串所表示数字的基），<code>2013</code> 年以前的 <code>JavaScript</code> 实现会返回一个意外的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;010&quot;</span>);  <span class="comment">//  8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0x10&quot;</span>); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<p>这是因为字符串以数字 <code>0</code> 开头，<code>parseInt()</code>函数会把这样的字符串视作八进制数字；同理，<code>0x</code>开头的字符串则视为十六进制数字。</p>
<p>如果想把一个二进制数字字符串转换成整数值，只要把第二个参数设置为 <code>2</code> 就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;11&quot;</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><code>JavaScript</code> 还有一个类似的内置函数 <code>parseFloat()</code>，用以解析浮点数字符串，与 <code>parseInt()</code> 不同的地方是，<code>parseFloat()</code>只应用于解析十进制数字。</p>
<p>单元运算符 + 也可以把数字字符串转换成数值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="string">&quot;42&quot;</span>;   <span class="comment">// 42</span></span><br><span class="line">+ <span class="string">&quot;010&quot;</span>;  <span class="comment">// 10</span></span><br><span class="line">+ <span class="string">&quot;0x10&quot;</span>; <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<p>如果给定的字符串不存在数值形式，函数会返回一个特殊的值 <code>NaN</code>（<code>Not a Number</code> 的缩写）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>要小心<code>NaN</code>：如果把 <code>NaN</code> 作为参数进行任何数学运算，结果也会是 <code>NaN</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> + <span class="number">5</span>; <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<p>可以使用内置函数 <code>isNaN()</code> 来判断一个变量是否为 <code>NaN</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>JavaScript</code> 还有两个特殊值：<code>Infinity</code>（正无穷）和 <code>-Infinity</code>（负无穷）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / <span class="number">0</span>; <span class="comment">//  Infinity</span></span><br><span class="line">-<span class="number">1</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>

<p>可以使用内置函数 <code>isFinite()</code> 来判断一个变量是否是一个有穷数， 如果类型为 <code>Infinity</code>, <code>-Infinity</code> 或 <code>NaN</code>则返回<code>false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="number">1</span>/<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="title class_">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="title class_">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="number">2e64</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">&quot;0&quot;</span>); <span class="comment">// true,如果是纯数值类型的检测，则返回false：Number.isFinite(&quot;0&quot;);</span></span><br></pre></td></tr></table></figure>


<p>备注： <code>parseInt()</code> 和 <code>parseFloat()</code> 函数会尝试逐个解析字符串中的字符，直到遇上一个无法被解析成数字的字符，然后返回该字符前所有数字字符组成的数字。使用运算符 “<code>+</code>“ 将字符串转换成数字，只要字符串中含有无法被解析成数字的字符，该字符串都将被转换成 <code>NaN</code>。请你用这两种方法分别解析“<code>10.2abc</code>”这一字符串，比较得到的结果，理解这两种方法的区别。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><code>JavaScript</code> 中的字符串是一串<code>Unicode</code> 字符序列。这对于那些需要和多语种网页打交道的开发者来说是个好消息。更准确地说，它们是一串<code>UTF-16</code>编码单元的序列，每一个编码单元由一个 <code>16</code> 位二进制数表示。每一个<code>Unicode</code>字符由一个或两个编码单元来表示。</p>
<p>如果想表示一个单独的字符，只需使用长度为 <code>1</code> 的字符串。</p>
<p>通过访问字符串的长度（编码单元的个数）属性可以得到它的长度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="property">length</span>; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>这是我们第一次碰到 <code>JavaScript</code> 对象。我们有没有提过你可以像 <code>objects</code>  一样使用字符串？是的，字符串也有 <code>methods</code>（方法）能让你操作字符串和获取字符串的信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="title function_">charAt</span>(<span class="number">0</span>); <span class="comment">// &quot;h&quot;</span></span><br><span class="line"><span class="string">&quot;hello, world&quot;</span>.<span class="title function_">replace</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>); <span class="comment">// &quot;goodbye, world&quot;</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="title function_">toUpperCase</span>(); <span class="comment">// &quot;HELLO&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><p><code>JavaScript</code> 中 <code>null</code> 和 <code>undefined</code> 是不同的，前者表示一个空值（<code>non-value</code>），必须使用<code>null</code>关键字才能访问，后者是“<code>undefined</code>（未定义）”类型的对象，表示一个未初始化的值，也就是还没有被分配的值。我们之后再具体讨论变量，但有一点可以先简单说明一下，<code>JavaScript</code> 允许声明变量但不对其赋值，一个未被赋值的变量就是 <code>undefined</code> 类型。还有一点需要说明的是，<code>undefined</code> 实际上是一个不允许修改的常量。</p>
<p><code>JavaScript</code> 包含布尔类型，这个类型的变量有两个可能的值，分别是 <code>true</code> 和 <code>false</code>（两者都是关键字）。根据具体需要，<code>JavaScript</code> 按照如下规则将变量转换成布尔类型：</p>
<p><code>false</code>、<code>0</code>、空字符串(“”)、<code>NaN</code>、<code>null</code> 和 <code>undefined</code> 被转换为 <code>false</code><br>所有其他值被转换为 <code>true</code><br>也可以使用 <code>Boolean()</code> 函数进行显式转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">234</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>不过一般没必要这么做，因为 <code>JavaScript</code> 会在需要一个布尔变量时隐式完成这个转换操作（比如在 <code>if</code> 条件语句中）。所以，有时我们可以把转换成布尔值后的变量分别称为 真值（<code>true values</code>）——即值为 <code>true</code>  和 假值（<code>false values</code>）——即值为 <code>false</code>；也可以分别称为“真的”（<code>truthy</code>）和“假的”（<code>falsy</code>）。</p>
<p><code>JavaScript</code> 支持包括 <code>&amp;&amp;</code>（逻辑与）、<code>||</code> （逻辑或）和 <code>!</code>（逻辑非）在内的逻辑运算符。下面会有所提到。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在 <code>JavaScript</code> 中声明一个新变量的方法是使用关键字 <code>var</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;simon&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果声明了一个变量却没有对其赋值，那么这个变量的类型就是 <code>undefined</code>。</p>
<p><code>JavaScript</code> 与其他语言的（如 <code>Java</code>）的重要区别是在 <code>JavaScript</code> 中语句块（<code>blocks</code>）是没有作用域的，只有函数有作用域。因此如果在一个复合语句中（如 <code>if</code> 控制结构中）使用 <code>var</code> 声明一个变量，那么它的作用域是整个函数（复合语句在函数中）。 但是从 <code>ECMAScript</code> <code>Edition 6</code> 开始将有所不同的， <code>let</code> 和 <code>const</code> 关键字允许你创建块作用域的变量。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><code>JavaScript</code>的算术操作符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 和 <code>%</code> ——求余（与模运算不同）。赋值使用 <code>=</code> 运算符，此外还有一些复合运算符，如 <code>+=</code> 和 <code>-=</code>，它们等价于 <code>x = x op y</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x += <span class="number">5</span>; <span class="comment">// 等价于 x = x + 5;</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <code>++</code> 和 <code>--</code> 分别实现变量的自增和自减。两者都可以作为前缀或后缀操作符使用。</p>
<ul>
<li>操作符还可以用来连接字符串：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span> + <span class="string">&quot; world&quot;</span>; <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<p>如果你用一个字符串加上一个数字（或其他值），那么操作数都会被首先转换为字符串。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;3&quot;</span> + <span class="number">4</span> + <span class="number">5</span>; <span class="comment">// 345</span></span><br><span class="line"><span class="number">3</span> + <span class="number">4</span> + <span class="string">&quot;5&quot;</span>; <span class="comment">// 75</span></span><br></pre></td></tr></table></figure>

<p>这里不难看出一个实用的技巧——通过与空字符串相加，可以将某个变量快速转换成字符串类型。</p>
<p><code>JavaScript</code> 中的比较操作使用 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code> 和 <code>&gt;=</code>，这些运算符对于数字和字符串都通用。相等的比较稍微复杂一些。由两个“<code>=</code>（等号）”组成的相等运算符有类型自适应的功能，具体例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> == <span class="string">&quot;123&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果在比较前不需要自动类型转换，应该使用由三个“<code>=</code>（等号）”组成的相等运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="literal">true</span>; <span class="comment">//false</span></span><br><span class="line"><span class="number">123</span> === <span class="string">&quot;123&quot;</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>JavaScript</code> 还支持 <code>!=</code> 和 <code>!==</code> 两种不等运算符，具体区别与两种相等运算符的区别类似。</p>
<p><code>JavaScript</code> 还提供了 位操作符。</p>
<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p><code>JavaScript</code> 的控制结构与其他类 <code>C</code> 语言类似。可以使用 <code>if</code> 和 <code>else</code> 来定义条件语句，还可以连起来使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;kittens&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">&quot;puppies&quot;</span>) &#123;</span><br><span class="line">  name += <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;kittens&quot;</span>) &#123;</span><br><span class="line">  name += <span class="string">&quot;!!&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;!&quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line">name == <span class="string">&quot;kittens!!&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>JavaScript</code> 支持 <code>while</code> 循环和 <code>do-while </code>循环。前者适合常见的基本循环操作，如果需要循环体至少被执行一次则可以使用 <code>do-while</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 一个无限循环！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  input = <span class="title function_">get_input</span>();</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="title function_">inputIsNotValid</span>(input))</span><br></pre></td></tr></table></figure>


<p><code>JavaScript</code> 的 <code>for</code> 循环与 <code>C</code> 和 <code>Java</code> 中的相同，使用时可以在一行代码中提供控制信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 将会执行五次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&amp;&amp;</code> 和 <code>||</code> 运算符使用短路逻辑（<code>short-circuit logic</code>），是否会执行第二个语句（操作数）取决于第一个操作数的结果。在需要访问某个对象的属性时，使用这个特性可以事先检测该对象是否为空：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = o &amp;&amp; o.<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<p>或运算可以用来设置默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = otherName || <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>类似地，<code>JavaScript</code> 也有一个用于条件表达式的三元操作符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allowed = (age &gt; <span class="number">18</span>) ? <span class="string">&quot;yes&quot;</span> : <span class="string">&quot;no&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在需要多重分支时可以使用  基于一个数字或字符串的 <code>switch</code> 语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(action) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;draw&#x27;</span>:</span><br><span class="line">        <span class="title function_">drawIt</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;eat&#x27;</span>:</span><br><span class="line">        <span class="title function_">eatIt</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="title function_">doNothing</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你不使用 <code>break</code> 语句，<code>JavaScript</code> 解释器将会执行之后 <code>case</code> 中的代码。除非是为了调试，一般你并不需要这个特性，所以大多数时候不要忘了加上 <code>break</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 继续向下</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="title function_">eatIt</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="title function_">doNothing</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>default</code> 语句是可选的。<code>switch</code> 和 <code>case</code> 都可以使用需要运算才能得到结果的表达式；在 <code>switch</code> 的表达式和 <code>case</code> 的表达式是使用 <code>===</code> 严格相等运算符进行比较的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="number">1</span> + <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> + <span class="number">2</span>:</span><br><span class="line">        <span class="title function_">yay</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="title function_">neverhappens</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><code>JavaScript</code> 中的对象可以简单理解成“名称-值”对，不难联想 <code>JavaScript</code> 中的对象与下面这些概念类似：</p>
<ul>
<li><code>Python</code> 中的字典</li>
<li><code>Perl</code> 和 <code>Ruby</code> 中的散列（哈希）</li>
<li><code>C/C++</code> 中的散列表</li>
<li><code>Java</code> 中的 <code>HashMap</code></li>
<li><code>PHP</code> 中的关联数组<br>这样的数据结构设计合理，能应付各类复杂需求，所以被各类编程语言广泛采用。正因为 <code>JavaScript</code> 中的一切（除了核心类型，<code>core object</code>）都是对象，所以 <code>JavaScript</code> 程序必然与大量的散列表查找操作有着千丝万缕的联系，而散列表擅长的正是高速查找。</li>
</ul>
<p>“名称”部分是一个 <code>JavaScript</code> 字符串，“值”部分可以是任何 <code>JavaScript</code> 的数据类型——包括对象。这使用户可以根据具体需求，创建出相当复杂的数据结构。</p>
<p>有两种简单方法可以创建一个空对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>和：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这两种方法在语义上是相同的。第二种更方便的方法叫作“对象字面量（<code>object literal</code>）”法。这种也是 <code>JSON</code> 格式的核心语法，一般我们优先选择第二种方法。</p>
<p>“对象字面量”也可以用来在对象实例中定义一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Carrot&quot;</span>,</span><br><span class="line">    <span class="string">&quot;for&quot;</span>: <span class="string">&quot;Max&quot;</span>,</span><br><span class="line">    <span class="attr">details</span>: &#123;</span><br><span class="line">        <span class="attr">color</span>: <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">        <span class="attr">size</span>: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象的属性可以通过链式（<code>chain</code>）表示方法进行访问：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">details</span>.<span class="property">color</span>; <span class="comment">// orange</span></span><br><span class="line">obj[<span class="string">&quot;details&quot;</span>][<span class="string">&quot;size&quot;</span>]; <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>下面的例子创建了一个对象原型，<code>Person</code>，和这个原型的实例，<code>You</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">You</span> = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;You&quot;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="comment">// 我们创建了一个新的 Person，名称是 &quot;You&quot;</span></span><br><span class="line"><span class="comment">// (&quot;You&quot; 是第一个参数, 24 是第二个参数..)</span></span><br></pre></td></tr></table></figure>

<p>完成创建后，对象属性可以通过如下两种方式进行赋值和访问：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;Simon&quot;</span></span><br><span class="line"><span class="keyword">var</span> name = obj.<span class="property">name</span>;</span><br></pre></td></tr></table></figure>

<p>和：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Simon&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> name = obj[<span class="string">&quot;name&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>这两种方法在语义上也是相同的。第二种方法的优点在于属性的名称被看作一个字符串，这就意味着它可以在运行时被计算，缺点在于这样的代码有可能无法在后期被解释器优化。它也可以被用来访问某些以预留关键字作为名称的属性的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">for</span> = <span class="string">&quot;Simon&quot;</span>; <span class="comment">// 语法错误，因为 for 是一个预留关键字</span></span><br><span class="line">obj[<span class="string">&quot;for&quot;</span>] = <span class="string">&quot;Simon&quot;</span>; <span class="comment">// 工作正常</span></span><br></pre></td></tr></table></figure>

<p>注意：从 <code>EcmaScript 5 </code>开始，预留关键字可以作为对象的属性名（<code>reserved words may be used as object property names &quot;in the buff&quot;</code>）。 这意味着当定义对象字面量时不需要用双引号了。参见 <code>ES5 Spec</code>.<br>关于对象和原型的详情参见： <code>Object.prototype</code>.</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>JavaScript</code> 中的数组是一种特殊的对象。它的工作原理与普通对象类似（以数字为属性名，但只能通过<code>[]</code> 来访问），但数组还有一个特殊的属性——<code>length</code>（长度）属性。这个属性的值通常比数组最大索引大 <code>1</code>。</p>
<p>创建数组的传统方法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="string">`Array`</span>();</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="string">&quot;hen&quot;</span>;</span><br><span class="line">a.<span class="property">length</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>使用数组字面量（<code>array literal</code>）法更加方便：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;hen&quot;</span>];</span><br><span class="line">a.<span class="property">length</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>Array.length</code> 并不总是等于数组中元素的个数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;hen&quot;</span>];</span><br><span class="line">a[<span class="number">100</span>] = <span class="string">&quot;fox&quot;</span>;</span><br><span class="line">a.<span class="property">length</span>; <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>

<p>记住：数组的长度是比数组最大索引值多一的数。</p>
<p>如果试图访问一个不存在的数组索引，会得到 <code>undefined</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">typeof</span>(a[<span class="number">90</span>]); <span class="comment">// `undefined`</span></span><br></pre></td></tr></table></figure>

<p>可以通过如下方式遍历一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// Do something with a[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历数组的另一种方法是使用 <code>for...in</code> 循环。注意，如果有人向 <code>Array.prototype</code> 添加了新的属性，使用这样的循环这些属性也同样会被遍历。所以并不推荐这种方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="comment">// Do something with a[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ECMAScript 5</code> 增加了遍历数组的另一个方法 <code>forEach()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;hen&quot;</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// Do something with currentValue or array[index]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果想在数组后追加元素，只需要：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">push</span>(item);</span><br></pre></td></tr></table></figure>

<p><code>Array</code>（数组）类自带了许多方法。查看 <code>array</code> 方法的完整文档。</p>
<table>
<thead>
<tr>
<th align="left">方法名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a.toString()</td>
<td align="left">返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔。</td>
</tr>
<tr>
<td align="left">a.toLocaleString()</td>
<td align="left">根据宿主环境的区域设置，返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔。</td>
</tr>
<tr>
<td align="left">a.concat(item1[, item2[, …[, itemN]]])</td>
<td align="left">返回一个数组，这个数组包含原先 a 和 item1、item2、……、itemN 中的所有元素。</td>
</tr>
<tr>
<td align="left">a.join(sep)</td>
<td align="left">返回一个包含数组中所有元素的字符串，每个元素通过指定的 sep 分隔。</td>
</tr>
<tr>
<td align="left">a.pop()</td>
<td align="left">删除并返回数组中的最后一个元素。</td>
</tr>
<tr>
<td align="left">a.push(item1, …, itemN)</td>
<td align="left">将 item1、item2、……、itemN 追加至数组 a。</td>
</tr>
<tr>
<td align="left">a.reverse()</td>
<td align="left">数组逆序（会更改原数组 a）。</td>
</tr>
<tr>
<td align="left">a.shift()</td>
<td align="left">删除并返回数组中第一个元素。</td>
</tr>
<tr>
<td align="left">a.slice(start, end)</td>
<td align="left">返回子数组，以 a[start] 开头，以 a[end] 前一个元素结尾。</td>
</tr>
<tr>
<td align="left">a.sort([cmpfn])</td>
<td align="left">依据 cmpfn 返回的结果进行排序，如果未指定比较函数则按字符顺序比较（即使元素是数字）。</td>
</tr>
<tr>
<td align="left">a.splice(start, delcount[, item1[, …[, itemN]]])</td>
<td align="left">从 start 开始，删除delcount个元素，然后插入所有的</td>
</tr>
<tr>
<td align="left">a.unshift([item])</td>
<td align="left">将 item 插入数组头部，返回数组新长度（考虑 undefined）。</td>
</tr>
</tbody></table>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>学习 <code>JavaScript</code> 最重要的就是要理解对象和函数两个部分。最简单的函数就像下面这个这么简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> total = x + y;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子包括你需要了解的关于基本函数的所有部分。一个 <code>JavaScript</code> 函数可以包含 <code>0</code> 个或多个已命名的变量。函数体中的表达式数量也没有限制。你可以声明函数自己的局部变量。<code>return </code>语句在返回一个值并结束函数。如果没有使用 <code>return</code> 语句，或者一个没有值的 <code>return</code> 语句，<code>JavaScript</code> 会返回 <code>undefined</code>。</p>
<p>已命名的参数更像是一个指示而没有其他作用。如果调用函数时没有提供足够的参数，缺少的参数会被 <code>undefined</code> 替代。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">add</span>(); <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 不能在 `undefined` 对象上进行加法操作</span></span><br></pre></td></tr></table></figure>

<p>你还可以传入多于函数本身需要参数个数的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br><span class="line"> <span class="comment">// 将前两个值相加，4被忽略了</span></span><br></pre></td></tr></table></figure>

<p>这看上去有点蠢。函数实际上是访问了函数体中一个名为 <code>arguments</code> 的内部对象，这个对象就如同一个类似于数组的对象一样，包括了所有被传入的参数。让我们重写一下上面的函数，使它可以接收任意个数的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="variable language_">arguments</span>.<span class="property">length</span>; i &lt; j; i++) &#123;</span><br><span class="line">        sum += <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>

<p>这跟直接写成 <code>2 + 3 + 4 + 5</code> 也没什么区别。接下来创建一个求平均数的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">avg</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="variable language_">arguments</span>.<span class="property">length</span>; i &lt; j; i++) &#123;</span><br><span class="line">        sum += <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / <span class="variable language_">arguments</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">avg</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 3.5</span></span><br></pre></td></tr></table></figure>

<p>这个很有用，但是却带来了新的问题。<code>avg()</code> 函数处理一个由逗号连接的变量串，但如果想得到一个数组的平均值该怎么办呢？可以这么修改函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> avg<span class="string">`Array`</span>(arr) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = arr.<span class="property">length</span>; i &lt; j; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / arr.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line">avg<span class="string">`Array`</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 3.5</span></span><br></pre></td></tr></table></figure>

<p>但如果能重用我们已经创建的那个函数不是更好吗？幸运的是 <code>JavaScript</code> 允许使用任意函数对象的<code>apply() </code>方法来调用该函数，并传递给它一个包含了参数的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avg.<span class="title function_">apply</span>(<span class="string">`null`</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 3.5</span></span><br></pre></td></tr></table></figure>

<p>传给 <code>apply()</code> 的第二个参数是一个数组，它将被当作 <code>avg()</code> 的参数使用，至于第一个参数 <code>null</code>，我们将在后面讨论。这也正说明一个事实——函数也是对象。</p>
<p><code>JavaScript</code> 允许你创建匿名函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> avg = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="variable language_">arguments</span>.<span class="property">length</span>; i &lt; j; i++) &#123;</span><br><span class="line">        sum += <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / <span class="variable language_">arguments</span>.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个函数在语义上与 <code>function avg()</code> 相同。你可以在代码中的任何地方定义这个函数，就像写普通的表达式一样。基于这个特性，有人发明出一些有趣的技巧。与 <code>C</code> 中的块级作用域类似，下面这个例子隐藏了局部变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">    a += b;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// 4</span></span><br><span class="line">b; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><code>JavaScript</code> 允许以递归方式调用函数。递归在处理树形结构（比如浏览器 <code>DOM</code>）时非常有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countChars</span>(<span class="params">elm</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elm.<span class="property">nodeType</span> == <span class="number">3</span>) &#123; <span class="comment">// 文本节点</span></span><br><span class="line">        <span class="keyword">return</span> elm.<span class="property">nodeValue</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, child; child = elm.<span class="property">childNodes</span>[i]; i++) &#123;</span><br><span class="line">        count += <span class="title function_">countChars</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里需要说明一个潜在问题——既然匿名函数没有名字，那该怎么递归调用它呢？在这一点上，<code>JavaScript</code> 允许你命名这个函数表达式。你可以命名立即调用的函数表达式（<code>IIFES——Immediately Invoked Function Expressions</code>），如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> charsInBody = (<span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params">elm</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elm.<span class="property">nodeType</span> == <span class="number">3</span>) &#123; <span class="comment">// 文本节点</span></span><br><span class="line">        <span class="keyword">return</span> elm.<span class="property">nodeValue</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, child; child = elm.<span class="property">childNodes</span>[i]; i++) &#123;</span><br><span class="line">        count += <span class="title function_">counter</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;)(<span class="variable language_">document</span>.<span class="property">body</span>);</span><br></pre></td></tr></table></figure>

<p>如上所提供的函数表达式的名称的作用域仅仅是该函数自身。这允许引擎去做更多的优化，并且这种实现更可读、友好。该名称也显示在调试器和一些堆栈跟踪中，节省了调试时的时间。</p>
<p>需要注意的是 <code>JavaScript</code> 函数是它们本身的对象——就和 <code>JavaScript</code> 其他一切一样——你可以给它们添加属性或者更改它们的属性，这与前面的对象部分一样。</p>
<h2 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h2><p>备注：关于 <code>JavaScript</code> 中面向对象编程更详细的信息，请参考 <code>JavaScript</code> 面向对象简介。<br>在经典的面向对象语言中，对象是指数据和在这些数据上进行的操作的集合。与 <code>C++</code> 和 <code>Java</code> 不同，<code>JavaScript</code> 是一种基于原型的编程语言，并没有 <code>class</code> 语句，而是把函数用作类。那么让我们来定义一个人名对象，这个对象包括人的姓和名两个域（<code>field</code>）。名字的表示有两种方法：“名 姓（<code>First Last</code>）”或“姓, 名（<code>Last</code>, <code>First</code>）”。使用我们前面讨论过的函数和对象概念，可以像这样完成定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makePerson</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">first</span>: first,</span><br><span class="line">        <span class="attr">last</span>: last</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">personFullName</span>(<span class="params">person</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> person.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + person.<span class="property">last</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">personFullNameReversed</span>(<span class="params">person</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> person.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + person.<span class="property">first</span></span><br><span class="line">&#125;</span><br><span class="line">s = <span class="title function_">makePerson</span>(<span class="string">&quot;Simon&quot;</span>, <span class="string">&quot;Willison&quot;</span>);</span><br><span class="line"><span class="title function_">personFullName</span>(s); <span class="comment">// Simon Willison</span></span><br><span class="line"><span class="title function_">personFullNameReversed</span>(s); <span class="comment">// Willison, Simon</span></span><br></pre></td></tr></table></figure>

<p>上面的写法虽然可以满足要求，但是看起来很麻烦，因为需要在全局命名空间中写很多函数。既然函数本身就是对象，如果需要使一个函数隶属于一个对象，那么不难得到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makePerson</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">first</span>: first,</span><br><span class="line">        <span class="attr">last</span>: last,</span><br><span class="line">        <span class="attr">fullName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fullNameReversed</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">s = <span class="title function_">makePerson</span>(<span class="string">&quot;Simon&quot;</span>, <span class="string">&quot;Willison&quot;</span>);</span><br><span class="line">s.<span class="title function_">fullName</span>(); <span class="comment">// Simon Willison</span></span><br><span class="line">s.<span class="title function_">fullNameReversed</span>(); <span class="comment">// Willison, Simon</span></span><br></pre></td></tr></table></figure>

<p>上面的代码里有一些我们之前没有见过的东西：关键字 <code>this</code>。当使用在函数中时，<code>this</code> 指代当前的对象，也就是调用了函数的对象。如果在一个对象上使用点或者方括号来访问属性或方法，这个对象就成了 <code>this</code>。如果并没有使用“点”运算符调用某个对象，那么 <code>this</code> 将指向全局对象（<code>global object</code>）。这是一个经常出错的地方。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="title function_">makePerson</span>(<span class="string">&quot;Simon&quot;</span>, <span class="string">&quot;Willison&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fullName = s.<span class="property">fullName</span>;</span><br><span class="line"><span class="title function_">fullName</span>(); <span class="comment">// `undefined` `undefined`</span></span><br></pre></td></tr></table></figure>

<p>当我们调用 <code>fullName()</code> 时，<code>this</code> 实际上是指向全局对象的，并没有名为 <code>first</code> 或 <code>last</code> 的全局变量，所以它们两个的返回值都会是 <code>undefined</code>。</p>
<p>下面使用关键字 <code>this</code> 改进已有的 <code>makePerson</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = last;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullNameReversed</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Simon&quot;</span>, <span class="string">&quot;Willison&quot;</span>);\</span><br></pre></td></tr></table></figure>

<p>我们引入了另外一个关键字：<code>new</code>，它和 <code>this</code> 密切相关。它的作用是创建一个崭新的空对象，然后使用指向那个对象的 <code>this</code> 调用特定的函数。注意，含有 <code>this</code> 的特定函数不会返回任何值，只会修改 <code>this</code> 对象本身。<code>new</code> 关键字将生成的 <code>this</code> 对象返回给调用方，而被 <code>new</code> 调用的函数成为构造函数。习惯的做法是将这些函数的首字母大写，这样用 <code>new</code> 调用他们的时候就容易识别了。</p>
<p>不过这个改进的函数还是和上一个例子一样，单独调用<code>fullName()</code> 时会产生相同的问题。</p>
<p>我们的 <code>Person</code> 对象现在已经相当完善了，但还有一些不太好的地方。每次我们创建一个 <code>Person</code> 对象的时候，我们都在其中创建了两个新的函数对象——如果这个代码可以共享不是更好吗？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">personFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">personFullNameReversed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = last;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullName</span> = personFullName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullNameReversed</span> = personFullNameReversed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法的好处是，我们只需要创建一次方法函数，在构造函数中引用它们。那是否还有更好的方法呢？答案是肯定的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">fullName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">fullNameReversed</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Person.prototype </code>是一个可以被<code>Person</code>的所有实例共享的对象。它是一个名叫原型链（<code>prototype chain</code>）的查询链的一部分：当你试图访问一个 <code>Person </code>没有定义的属性时，解释器会首先检查这个<code>Person.prototype</code>来判断是否存在这样一个属性。所以，任何分配给 <code>Person.prototype</code> 的东西对通过 <code>this</code> 对象构造的实例都是可用的。</p>
<p>这个特性功能十分强大，<code>JavaScript</code> 允许你在程序中的任何时候修改原型（<code>prototype</code>）中的一些东西，也就是说你可以在运行时(<code>runtime</code>)给已存在的对象添加额外的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Simon&quot;</span>, <span class="string">&quot;Willison&quot;</span>);</span><br><span class="line">s.<span class="title function_">firstNameCaps</span>();  <span class="comment">// TypeError on line 1: s.firstNameCaps is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">firstNameCaps</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span>.<span class="title function_">toUpperCase</span>()</span><br><span class="line">&#125;</span><br><span class="line">s.<span class="title function_">firstNameCaps</span>(); <span class="comment">// SIMON</span></span><br></pre></td></tr></table></figure>

<p>有趣的是，你还可以给 <code>JavaScript</code> 的内置函数原型（<code>prototype</code>）添加东西。让我们给 <code>String</code> 添加一个方法用来返回逆序的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;Simon&quot;</span>;</span><br><span class="line">s.<span class="title function_">reversed</span>(); <span class="comment">// TypeError on line 1: s.reversed is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reversed</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        r += <span class="variable language_">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">s.<span class="title function_">reversed</span>(); <span class="comment">// nomiS</span></span><br></pre></td></tr></table></figure>

<p>定义新方法也可以在字符串字面量上用（<code>string literal</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;This can now be reversed&quot;</span>.<span class="title function_">reversed</span>(); <span class="comment">// desrever eb won nac sihT</span></span><br></pre></td></tr></table></figure>

<p>正如我前面提到的，原型组成链的一部分。那条链的根节点是 <code>Object.prototype</code>，它包括 <code>toString() </code>方法——将对象转换成字符串时调用的方法。这对于调试我们的 <code>Person</code> 对象很有用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Simon&quot;</span>, <span class="string">&quot;Willison&quot;</span>);</span><br><span class="line">s; <span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;Person: &#x27;</span> + <span class="variable language_">this</span>.<span class="title function_">fullName</span>() + <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">s.<span class="title function_">toString</span>(); <span class="comment">// &lt;Person: Simon Willison&gt;</span></span><br></pre></td></tr></table></figure>

<p>你是否还记得之前我们说的 <code>avg.apply()</code> 中的第一个参数 <code>null</code>？现在我们可以回头看看这个东西了。<code>apply()</code> 的第一个参数应该是一个被当作 <code>this</code> 来看待的对象。下面是一个 <code>new</code> 方法的简单实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trivialNew</span>(<span class="params">constructor, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;; <span class="comment">// 创建一个对象</span></span><br><span class="line">    constructor.<span class="title function_">apply</span>(o, args);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这并不是 <code>new</code> 的完整实现，因为它没有创建原型（<code>prototype</code>）链。想举例说明 <code>new</code> 的实现有些困难，因为你不会经常用到这个，但是适当了解一下还是很有用的。在这一小段代码里，<code>...args</code>（包括省略号）叫作剩余参数（<code>rest arguments</code>）。如名所示，这个东西包含了剩下的参数。</p>
<p>因此调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bill = <span class="title function_">trivialNew</span>(<span class="title class_">Person</span>, <span class="string">&quot;William&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可认为和调用如下语句是等效的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bill = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;William&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>apply()</code> 有一个姐妹函数，名叫 <code>call</code>，它也可以允许你设置 <code>this</code>，但它带有一个扩展的参数列表而不是一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lastNameCaps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span>.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Simon&quot;</span>, <span class="string">&quot;Willison&quot;</span>);</span><br><span class="line">lastNameCaps.<span class="title function_">call</span>(s);</span><br><span class="line"><span class="comment">// 和以下方式等价</span></span><br><span class="line">s.<span class="property">lastNameCaps</span> = lastNameCaps;</span><br><span class="line">s.<span class="title function_">lastNameCaps</span>();</span><br></pre></td></tr></table></figure>

<h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p><code>JavaScript</code> 允许在一个函数内部定义函数，这一点我们在之前的 <code>makePerson()</code> 例子中也见过。关于 <code>JavaScript</code> 中的嵌套函数，一个很重要的细节是它们可以访问父函数作用域中的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">betterExampleNeeded</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">oneMoreThanA</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">oneMoreThanA</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某个函数依赖于其他的一两个函数，而这一两个函数对你其余的代码没有用处，你可以将它们嵌套在会被调用的那个函数内部，这样做可以减少全局作用域下的函数的数量，这有利于编写易于维护的代码。</p>
<p>这也是一个减少使用全局变量的好方法。当编写复杂代码时，程序员往往试图使用全局变量，将值共享给多个函数，但这样做会使代码很难维护。内部函数可以共享父函数的变量，所以你可以使用这个特性把一些函数捆绑在一起，这样可以有效地防止“污染”你的全局命名空间——你可以称它为“局部全局（<code>local global</code>）”。虽然这种方法应该谨慎使用，但它确实很有用，应该掌握。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>下面我们将看到的是 <code>JavaScript</code> 中必须提到的功能最强大的抽象概念之一：闭包。但它可能也会带来一些潜在的困惑。那它究竟是做什么的呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeAdder</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">makeAdder</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> y = <span class="title function_">makeAdder</span>(<span class="number">20</span>);</span><br><span class="line"><span class="title function_">x</span>(<span class="number">6</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="title function_">y</span>(<span class="number">7</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p><code>makeAdder</code> 这个名字本身应该能说明函数是用来做什么的：它创建了一个新的 <code>adder</code> 函数，这个函数自身带有一个参数，它被调用的时候这个参数会被加在外层函数传进来的参数上。</p>
<p>这里发生的事情和前面介绍过的内嵌函数十分相似：一个函数被定义在了另外一个函数的内部，内部函数可以访问外部函数的变量。唯一的不同是，外部函数被返回了，那么常识告诉我们局部变量“应该”不再存在。但是它们却仍然存在——否则 <code>adder</code> 函数将不能工作。也就是说，这里存在 <code>makeAdder</code> 的局部变量的两个不同的“副本”——一个是 <code>a</code> 等于<code>5</code>，另一个是 <code>a</code> 等于<code>20</code>。那些函数的运行结果就如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">x</span>(<span class="number">6</span>); <span class="comment">// 返回 11</span></span><br><span class="line"><span class="title function_">y</span>(<span class="number">7</span>); <span class="comment">// 返回 27</span></span><br></pre></td></tr></table></figure>

<p>下面来说说到底发生了什么。每当 <code>JavaScript</code> 执行一个函数时，都会创建一个作用域对象（<code>scope object</code>），用来保存在这个函数中创建的局部变量。它和被传入函数的变量一起被初始化。这与那些保存的所有全局变量和函数的全局对象（<code>global object</code>）类似，但仍有一些很重要的区别，第一，每次函数被执行的时候，就会创建一个新的，特定的作用域对象；第二，与全局对象（在浏览器里面是当做 window 对象来访问的）不同的是，你不能从 <code>JavaScript</code> 代码中直接访问作用域对象，也没有可以遍历当前的作用域对象里面属性的方法。</p>
<p>所以当调用 <code>makeAdder </code>时，解释器创建了一个作用域对象，它带有一个属性：<code>a</code>，这个属性被当作参数传入 <code>makeAdder</code> 函数。然后 <code>makeAdder</code> 返回一个新创建的函数。通常 <code>JavaScript</code> 的垃圾回收器会在这时回收 <code>makeAdder</code> 创建的作用域对象，但是返回的函数却保留一个指向那个作用域对象的引用。结果是这个作用域对象不会被垃圾回收器回收，直到指向 <code>makeAdder</code> 返回的那个函数对象的引用计数为零。</p>
<p>作用域对象组成了一个名为作用域链（<code>scope chain</code>）的链。它类似于原形（<code>prototype</code>）链一样，被 <code>JavaScript</code> 的对象系统使用。</p>
<p>一个闭包就是一个函数和被创建的函数中的作用域对象的组合。</p>
<p>闭包允许你保存状态——所以它们通常可以代替对象来使用。这里有一些关于闭包的详细介绍。</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>使用闭包的一个坏处是，在 <code>IE</code> 浏览器中它会很容易导致内存泄露。<code>JavaScript</code> 是一种具有垃圾回收机制的语言——对象在被创建的时候分配内存，然后当指向这个对象的引用计数为零时，浏览器会回收内存。宿主环境提供的对象都是按照这种方法被处理的。</p>
<p>浏览器主机需要处理大量的对象来描绘一个正在被展现的 <code>HTML</code> 页面——<code>DOM</code> 对象。浏览器负责管理它们的内存分配和回收。</p>
<p><code>IE</code> 浏览器有自己的一套垃圾回收机制，这套机制与 <code>JavaScript</code> 提供的垃圾回收机制进行交互时，可能会发生内存泄露。</p>
<p>在 <code>IE</code> 中，每当在一个 <code>JavaScript</code> 对象和一个本地对象之间形成循环引用时，就会发生内存泄露。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">leakMemory</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;el&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> o = &#123; <span class="string">&#x27;el&#x27;</span>: el &#125;;</span><br><span class="line">    el.<span class="property">o</span> = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的循环引用会导致内存泄露：<code>IE</code> 不会释放被 <code>el</code> 和 <code>o</code> 使用的内存，直到浏览器被彻底关闭并重启后。</p>
<p>这个例子往往无法引起人们的重视：一般只会在长时间运行的应用程序中，或者因为巨大的数据量和循环中导致内存泄露发生时，内存泄露才会引起注意。</p>
<p>不过一般也很少发生如此明显的内存泄露现象——通常泄露的数据结构有多层的引用(<code>references</code>)，往往掩盖了循环引用的情况。</p>
<p>闭包很容易发生无意识的内存泄露。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;el&#x27;</span>);</span><br><span class="line">    el.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个元素，当它被点击的时候变红，但同时它也会发生内存泄露。为什么？因为对 <code>el</code> 的引用不小心被放在一个匿名内部函数中。这就在 <code>JavaScript</code> 对象（这个内部函数）和本地对象之间（<code>el</code>）创建了一个循环引用。</p>
<p>这个问题有很多种解决方法，最简单的一种是不要使用 <code>el</code> 变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;el&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有趣的是，有一种窍门解决因闭包而引入的循环引用，是添加另外一个闭包：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> clickHandler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;el&#x27;</span>);</span><br><span class="line">        el.<span class="property">onclick</span> = clickHandler;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部函数被直接执行，并在 <code>clickHandler</code> 创建的闭包中隐藏了它的内容。</p>
<p>另外一种避免闭包的好方法是在 <code>window.onunload</code> 事件发生期间破坏循环引用。很多事件库都能完成这项工作。注意这样做将使 <code>Firefox</code> 中的 <code>bfcache</code> 无法工作。所以除非有其他必要的原因，最好不要在 <code>Firefox</code> 中注册一个 <code>onunload</code> 的监听器。</p>
<p>原文来自：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript">重新介绍 JavaScript（JS 教程）</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/entry/595a40785188250d92086765/detail"><img src="https://badge.juejin.im/entry/595a40785188250d92086765/likes.svg?style=flat-square"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/07/03/A_re-introduction_to_JavaScript/" data-id="clrm0xvtb0000lqn9ejpb1v12" data-title="重新介绍 JavaScript（JS全面系列教程）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Function/" rel="tag">Function</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/07/06/comment_ru_he_xuan_ze/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          继多说、网易关停之后该何去何从(网易云跟帖宣布2017年8月1日停止服务)
        
      </div>
    </a>
  
  
    <a href="/2017/06/22/blog-comment-gentie-remind/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">博客评论网易云跟帖评论提醒功能</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS3/">CSS3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Canvas/">Canvas</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cron/">Cron</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ElasticStack/">ElasticStack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo%E5%8D%9A%E5%AE%A2/">Hexo博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Interview/">Interview</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%95%99%E7%A8%8B/">Java教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MongoDB/">MongoDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringReactive/">SpringReactive</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebRTC/">WebRTC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/PWA/">PWA</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/rust/">rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shadowsocks/">shadowsocks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/">安全认证</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BlueLake/" rel="tag">BlueLake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas/" rel="tag">Canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CentOS/" rel="tag">CentOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Config/" rel="tag">Config</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cron/" rel="tag">Cron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticStack/" rel="tag">ElasticStack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eureka/" rel="tag">Eureka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FastDFS/" rel="tag">FastDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Function/" rel="tag">Function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gateway/" rel="tag">Gateway</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gogs/" rel="tag">Gogs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/" rel="tag">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/" rel="tag">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/" rel="tag">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Js%E6%A1%86%E6%9E%B6/" rel="tag">Js框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kibana/" rel="tag">Kibana</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LogStash/" rel="tag">LogStash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/" rel="tag">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac-OS/" rel="tag">Mac OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/" rel="tag">Markdown语法规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/" rel="tag">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NFS/" rel="tag">NFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nexus/" rel="tag">Nexus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/" rel="tag">NoSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJs/" rel="tag">NodeJs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenFeign/" rel="tag">OpenFeign</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWA/" rel="tag">PWA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Permissions/" rel="tag">Permissions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RBAC/" rel="tag">RBAC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSE/" rel="tag">SSE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVN/" rel="tag">SVN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sentinel/" rel="tag">Sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/" rel="tag">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringReactive/" rel="tag">SpringReactive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringSecurity/" rel="tag">SpringSecurity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thymeleaf/" rel="tag">Thymeleaf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Token/" rel="tag">Token</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat9/" rel="tag">Tomcat9</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebClient/" rel="tag">WebClient</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebFlux/" rel="tag">WebFlux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YApi/" rel="tag">YApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adb/" rel="tag">adb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adb%E5%91%BD%E4%BB%A4/" rel="tag">adb命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bower/" rel="tag">bower</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/comment/" rel="tag">comment</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/houyi1121/" rel="tag">houyi1121</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" rel="tag">js构造函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">js面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/" rel="tag">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pm2/" rel="tag">pm2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rust/" rel="tag">rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shadowsocks/" rel="tag">shadowsocks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/" rel="tag">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yarn/" rel="tag">yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/" rel="tag">伪元素</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%AA%E7%B1%BB/" rel="tag">伪类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B/" rel="tag">原型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" rel="tag">原型的基本概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="tag">原型链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%94%9FJs/" rel="tag">原生Js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">后端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/" rel="tag">安全认证</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%82%E7%AD%89/" rel="tag">幂等</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8%E6%B0%B4%E6%96%87/" rel="tag">日常水文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A2%A6%E9%AD%87/" rel="tag">梦魇</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A2%A6%E9%AD%87%E5%B0%8F%E6%A0%88/" rel="tag">梦魇小栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="tag">环境配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%BB%E5%B8%83/" rel="tag">画布</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" rel="tag">科学上网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF/" rel="tag">继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" rel="tag">继承的实现方式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" rel="tag">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10.59px;">Android</a> <a href="/tags/BlueLake/" style="font-size: 10.59px;">BlueLake</a> <a href="/tags/Canvas/" style="font-size: 11.18px;">Canvas</a> <a href="/tags/CentOS/" style="font-size: 15.29px;">CentOS</a> <a href="/tags/Config/" style="font-size: 10px;">Config</a> <a href="/tags/Cron/" style="font-size: 10.59px;">Cron</a> <a href="/tags/Docker/" style="font-size: 10.59px;">Docker</a> <a href="/tags/ElasticSearch/" style="font-size: 11.76px;">ElasticSearch</a> <a href="/tags/ElasticStack/" style="font-size: 11.76px;">ElasticStack</a> <a href="/tags/Eureka/" style="font-size: 10px;">Eureka</a> <a href="/tags/FastDFS/" style="font-size: 11.18px;">FastDFS</a> <a href="/tags/Function/" style="font-size: 10.59px;">Function</a> <a href="/tags/Gateway/" style="font-size: 10px;">Gateway</a> <a href="/tags/Git/" style="font-size: 10.59px;">Git</a> <a href="/tags/Gogs/" style="font-size: 10px;">Gogs</a> <a href="/tags/HTML5/" style="font-size: 11.18px;">HTML5</a> <a href="/tags/JQuery/" style="font-size: 13.53px;">JQuery</a> <a href="/tags/JVM/" style="font-size: 11.18px;">JVM</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Java/" style="font-size: 15.88px;">Java</a> <a href="/tags/Javascript/" style="font-size: 10px;">Javascript</a> <a href="/tags/Jenkins/" style="font-size: 11.76px;">Jenkins</a> <a href="/tags/Js%E6%A1%86%E6%9E%B6/" style="font-size: 13.53px;">Js框架</a> <a href="/tags/Kibana/" style="font-size: 11.76px;">Kibana</a> <a href="/tags/Linux/" style="font-size: 17.65px;">Linux</a> <a href="/tags/LogStash/" style="font-size: 11.76px;">LogStash</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Mac-OS/" style="font-size: 10px;">Mac OS</a> <a href="/tags/Markdown%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/" style="font-size: 10px;">Markdown语法规范</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MongoDB/" style="font-size: 10.59px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 13.53px;">MySQL</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/Nexus/" style="font-size: 10px;">Nexus</a> <a href="/tags/Nginx/" style="font-size: 10.59px;">Nginx</a> <a href="/tags/NoSQL/" style="font-size: 11.18px;">NoSQL</a> <a href="/tags/Node/" style="font-size: 12.94px;">Node</a> <a href="/tags/NodeJs/" style="font-size: 11.76px;">NodeJs</a> <a href="/tags/OpenFeign/" style="font-size: 10px;">OpenFeign</a> <a href="/tags/PWA/" style="font-size: 10px;">PWA</a> <a href="/tags/Permissions/" style="font-size: 10px;">Permissions</a> <a href="/tags/RBAC/" style="font-size: 10px;">RBAC</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/Redis/" style="font-size: 13.53px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 10.59px;">RocketMQ</a> <a href="/tags/SSE/" style="font-size: 10px;">SSE</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/Sentinel/" style="font-size: 10px;">Sentinel</a> <a href="/tags/Shell/" style="font-size: 12.35px;">Shell</a> <a href="/tags/Spring/" style="font-size: 18.82px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 13.53px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 12.35px;">SpringCloud</a> <a href="/tags/SpringReactive/" style="font-size: 12.94px;">SpringReactive</a> <a href="/tags/SpringSecurity/" style="font-size: 13.53px;">SpringSecurity</a> <a href="/tags/Thymeleaf/" style="font-size: 10px;">Thymeleaf</a> <a href="/tags/Token/" style="font-size: 10px;">Token</a> <a href="/tags/Tomcat9/" style="font-size: 10px;">Tomcat9</a> <a href="/tags/Ubuntu/" style="font-size: 12.35px;">Ubuntu</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/WebClient/" style="font-size: 10px;">WebClient</a> <a href="/tags/WebFlux/" style="font-size: 10px;">WebFlux</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/YApi/" style="font-size: 10px;">YApi</a> <a href="/tags/adb/" style="font-size: 10.59px;">adb</a> <a href="/tags/adb%E5%91%BD%E4%BB%A4/" style="font-size: 10.59px;">adb命令</a> <a href="/tags/bower/" style="font-size: 10px;">bower</a> <a href="/tags/comment/" style="font-size: 11.18px;">comment</a> <a href="/tags/hexo/" style="font-size: 12.35px;">hexo</a> <a href="/tags/houyi1121/" style="font-size: 10px;">houyi1121</a> <a href="/tags/java/" style="font-size: 14.71px;">java</a> <a href="/tags/javascript/" style="font-size: 17.06px;">javascript</a> <a href="/tags/js%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" style="font-size: 10px;">js构造函数</a> <a href="/tags/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">js面向对象</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/npm/" style="font-size: 11.18px;">npm</a> <a href="/tags/pm2/" style="font-size: 10px;">pm2</a> <a href="/tags/rust/" style="font-size: 10px;">rust</a> <a href="/tags/shadowsocks/" style="font-size: 10px;">shadowsocks</a> <a href="/tags/shell/" style="font-size: 12.94px;">shell</a> <a href="/tags/tools/" style="font-size: 10.59px;">tools</a> <a href="/tags/yarn/" style="font-size: 10px;">yarn</a> <a href="/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/" style="font-size: 10px;">伪元素</a> <a href="/tags/%E4%BC%AA%E7%B1%BB/" style="font-size: 10px;">伪类</a> <a href="/tags/%E5%8E%9F%E5%9E%8B/" style="font-size: 10px;">原型</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">原型的基本概念</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/" style="font-size: 10px;">原型链</a> <a href="/tags/%E5%8E%9F%E7%94%9FJs/" style="font-size: 14.12px;">原生Js</a> <a href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 20px;">后端开发</a> <a href="/tags/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/" style="font-size: 16.47px;">安全认证</a> <a href="/tags/%E5%B9%82%E7%AD%89/" style="font-size: 10px;">幂等</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.76px;">并发编程</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 14.12px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 18.24px;">数据结构</a> <a href="/tags/%E6%97%A5%E5%B8%B8%E6%B0%B4%E6%96%87/" style="font-size: 10px;">日常水文</a> <a href="/tags/%E6%A2%A6%E9%AD%87/" style="font-size: 10px;">梦魇</a> <a href="/tags/%E6%A2%A6%E9%AD%87%E5%B0%8F%E6%A0%88/" style="font-size: 10px;">梦魇小栈</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 19.41px;">环境配置</a> <a href="/tags/%E7%94%BB%E5%B8%83/" style="font-size: 11.18px;">画布</a> <a href="/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" style="font-size: 10px;">科学上网</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 17.65px;">算法</a> <a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 10px;">继承</a> <a href="/tags/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" style="font-size: 10px;">继承的实现方式</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">网络协议</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/17/rust-wechat-game-ylgy/">《羊了个羊》程序员过关攻略</a>
          </li>
        
          <li>
            <a href="/2022/08/15/data-structure-b-tree/">「数据结构与算法」B 树 与 B+ 树</a>
          </li>
        
          <li>
            <a href="/2022/07/25/data-structure-algorithm-method/">「数据结构与算法」常见算法思想</a>
          </li>
        
          <li>
            <a href="/2022/07/06/data-structure-trie-ac/">「数据结构与算法」Trie 树 与 AC 自动机</a>
          </li>
        
          <li>
            <a href="/2022/06/25/data-structure-text-pattern-algorithm/">「数据结构与算法」单模式字符串匹配算法（BF、RK、KMP、BM）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>