<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>「数据结构与算法」单模式字符串匹配算法（BF、RK、KMP、BM） | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="介绍字符串匹配算法之前，先定义几个概念：  主串Text: 长度记作 n； 模式串Pattern: 长度记作 m，并且 m&lt;&#x3D;n。 有效位移s（Valid Shift）：即模式串在主串中出现，并且位置移动 s 次。">
<meta property="og:type" content="article">
<meta property="og:title" content="「数据结构与算法」单模式字符串匹配算法（BF、RK、KMP、BM）">
<meta property="og:url" content="http://example.com/2022/06/25/data-structure-text-pattern-algorithm/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="介绍字符串匹配算法之前，先定义几个概念：  主串Text: 长度记作 n； 模式串Pattern: 长度记作 m，并且 m&lt;&#x3D;n。 有效位移s（Valid Shift）：即模式串在主串中出现，并且位置移动 s 次。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/01_01.png">
<meta property="og:image" content="http://example.com/01_02.png">
<meta property="og:image" content="http://example.com/01_07.png">
<meta property="og:image" content="http://example.com/01_08.png">
<meta property="og:image" content="http://example.com/01_09.png">
<meta property="og:image" content="http://example.com/01_10.png">
<meta property="og:image" content="http://example.com/01_03.png">
<meta property="og:image" content="http://example.com/01_04.png">
<meta property="og:image" content="http://example.com/01_05.png">
<meta property="og:image" content="http://example.com/01_06.png">
<meta property="og:image" content="http://example.com/01_11.png">
<meta property="og:image" content="http://example.com/01_13.png">
<meta property="og:image" content="http://example.com/01_12.png">
<meta property="article:published_time" content="2022-06-25T13:15:00.000Z">
<meta property="article:modified_time" content="2024-01-20T11:55:43.509Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/01_01.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-data-structure-text-pattern-algorithm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/25/data-structure-text-pattern-algorithm/" class="article-date">
  <time class="dt-published" datetime="2022-06-25T13:15:00.000Z" itemprop="datePublished">2022-06-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      「数据结构与算法」单模式字符串匹配算法（BF、RK、KMP、BM）
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>介绍字符串匹配算法之前，先定义几个概念：</p>
<ul>
<li><strong>主串</strong><code>Text</code>: 长度记作 <code>n</code>；</li>
<li><strong>模式串</strong><code>Pattern</code>: 长度记作 <code>m</code>，并且 <code>m&lt;=n</code>。</li>
<li>有效位移<code>s</code>（Valid Shift）：即模式串在主串中出现，并且位置移动 <code>s</code> 次。<br><img src="/01_01.png"></li>
</ul>
<span id="more"></span>

<h3 id="1-BF-算法"><a href="#1-BF-算法" class="headerlink" title="1. BF 算法"></a>1. BF 算法</h3><p>BF（Brute Force）算法，中文叫作暴力匹配算法，也叫朴素匹配算法。</p>
<p>从主串的首或尾开始逐个匹配字母（比较顺序没有限制）。<br><code>BF 算法</code>的思想可以用一句话来概括：在主串中，检查从起始位置 <code>0</code> 开始到 <code>n-m</code> 位置且长度为 <code>m</code> 的 <code>n-m+1</code> 个子串，看有没有跟模式串匹配的。如下图：</p>
<p><img src="/01_02.png"></p>
<p><code>BF 算法</code>从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。<br>我们每次都比对 <code>m</code> 个字符，要比对 <code>n-m+1</code> 次，所以，这种算法的最坏情况时间复杂度是 <code>O(n*m)</code>。</p>
<p>尽管理论上，<code>BF 算法</code>的时间复杂度很高，是 <code>O(n*m)</code>，但在实际的开发中，它却是一个比较常用的字符串匹配算法。原因有两点。</p>
<ul>
<li>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 <code>m</code> 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 <code>O(n*m)</code>，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</li>
<li>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/KISS%E5%8E%9F%E5%88%99">KISS（Keep it Simple and Stupid）设计原则</a>。</li>
</ul>
<h4 id="1-1-BF-算法总结"><a href="#1-1-BF-算法总结" class="headerlink" title="1.1 BF 算法总结"></a>1.1 BF 算法总结</h4><p><code>BF 算法</code>（Brute Force）是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。<br>尽管理论上的最坏情况时间复杂度很高，是 <code>O(n*m)</code>（<code>n</code>、<code>m</code> 表示主串和模式串的长度）。<br>但在实际的开发中，它却是一个比较常用的字符串匹配算法。因为这种算法实现简单，对于处理小规模的字符串匹配很好用。</p>
<h4 id="1-2-Java代码实现"><a href="#1-2-Java代码实现" class="headerlink" title="1.2 Java代码实现"></a>1.2 Java代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串暴力匹配算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bf</span><span class="params">(String text, String pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= m-<span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text.charAt(i+j) != pattern.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// j为已匹配的字符串下一个字符的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-RK-算法"><a href="#2-RK-算法" class="headerlink" title="2. RK 算法"></a>2. RK 算法</h3><p>RK（Rabin-Karp）算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。这个算法算是 <code>BF 算法</code>的升级版。</p>
<p><code>BF 算法</code>中，如果主串长度为 <code>n</code>，模式串长度为 <code>m</code>，那在主串中，就会有 <code>n-m+1</code> 个长度为 <code>m</code> 的子串与模式串匹配。但是，每次检查主串与子串是否匹配，需要依次比对每个字符，所以 <code>BF 算法</code>的时间复杂度就比较高，是 <code>O(n*m)</code>。</p>
<p><code>RK 算法</code>的思路：通过哈希算法对主串中的 <code>n-m+1</code> 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p>
<p>整个<code>RK 算法</code>包含两部分：<br>第一部分，计算子串哈希值；通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 <code>O(n)</code>。<br>第二部分，模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 <code>O(1)</code>，总共需要比较 <code>n-m+1</code> 个子串的哈希值，所以，这部分的时间复杂度也是 <code>O(n)</code>。<br>所以，<code>RK 算法</code>整体的时间复杂度就是 <code>O(n)</code>。<br>但是，当存在哈希冲突的时候，有可能存在子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 <code>O(n*m)</code>。但也不要太悲观，一般情况下，冲突不会很多，<code>RK 算法</code>的效率还是比 <code>BF 算法</code>高的。</p>
<h4 id="2-1-RK-算法总结"><a href="#2-1-RK-算法总结" class="headerlink" title="2.1 RK 算法总结"></a>2.1 RK 算法总结</h4><p><code>RK 算法</code>（Rabin-Karp）是对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。<br>理想情况下，<code>RK 算法</code>的时间复杂度是 <code>O(n)</code>。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 <code>O(n*m)</code>。</p>
<h4 id="2-2-Java代码实现"><a href="#2-2-Java代码实现" class="headerlink" title="2.2 Java代码实现"></a>2.2 Java代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rabin-Karp算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rk</span><span class="params">(String text, String pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123; <span class="keyword">return</span> -<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="comment">// 对模式串与第一个字串求哈希值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">patternCode</span> <span class="operator">=</span> pattern.hashCode();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> text.substring(<span class="number">0</span>, m);</span><br><span class="line">    <span class="type">int</span> <span class="variable">subCode</span> <span class="operator">=</span> sub.hashCode();</span><br><span class="line">    <span class="comment">// 对主串中的n-m+1个子串分别求哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n - m + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 哈希值相同，才进一步确认</span></span><br><span class="line">        <span class="keyword">if</span> (patternCode.equals(subCode) &amp;&amp; sub.equals(pattern)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续下一个子串</span></span><br><span class="line">        i++;</span><br><span class="line">        sub = text.substring(i, i + m);</span><br><span class="line">        subCode = sub.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-KMP-算法"><a href="#3-KMP-算法" class="headerlink" title="3. KMP 算法"></a>3. KMP 算法</h3><p>KMP（Knuth Morris Pratt）算法，是最常用的之一。它以三个发明者命名，很多时候，提到字符串匹配，我们首先想到的就是<code>KMP 算法</code>。</p>
<p><code>KMP 算法</code>的核心思想：<br>在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。</p>
<p>先了解几个概念：</p>
<ul>
<li><strong>前缀</strong>：指除了最后一个字符以外，一个字符串的全部头部组合；</li>
<li><strong>后缀</strong>：指除了第一个字符以外，一个字符串的全部尾部组合；</li>
<li><strong>部分匹配值</strong>：”前缀”和”后缀”的最长的共有元素的长度。</li>
</ul>
<p>以模式串”ABCDABD”为例：</p>
<table>
<thead>
<tr>
<th align="left">子串</th>
<th align="left">前缀</th>
<th align="left">后缀</th>
<th align="left">共有</th>
<th align="left">长度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A</td>
<td align="left">空</td>
<td align="left">空</td>
<td align="left">-</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">AB</td>
<td align="left">[A]</td>
<td align="left">[B]</td>
<td align="left">-</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">ABC</td>
<td align="left">[A, AB]</td>
<td align="left">[BC, C]</td>
<td align="left">-</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">ABCD</td>
<td align="left">[A, AB, ABC]</td>
<td align="left">[BCD, CD, D]</td>
<td align="left">-</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">ABCDA</td>
<td align="left">[A, AB, ABC, ABCD]</td>
<td align="left">[BCDA, CDA, DA, A]</td>
<td align="left">A</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">ABCDAB</td>
<td align="left">[A, AB, ABC, ABCD, ABCDA]</td>
<td align="left">[BCDAB, CDAB, DAB, AB, B]</td>
<td align="left">AB</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">ABCDABD</td>
<td align="left">[A, AB, ABC, ABCD, ABCDA, ABCDAB]</td>
<td align="left">[BCDABD, CDABD, DABD, ABD, BD, D]</td>
<td align="left">-</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>所以模式串”ABCDABD”的《部分匹配表》是：</p>
<table>
<thead>
<tr>
<th align="left">模式串</th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
<th align="left">D</th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">D</th>
</tr>
</thead>
<tbody><tr>
<td align="left">部分匹配表</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是<code>2</code>（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动<code>4</code>位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。<br>所以<code>KMP 算法</code>的后移规律：</p>
<blockquote>
<p>移动位数 &#x3D; 已匹配的字符数 - 对应的部分匹配值</p>
</blockquote>
<p>根据这个规律，我们以模式串”ABCDABD”来匹配字符串”BBC ABCDAB ABCDABCDABDE”。<code>KMP 算法</code>的匹配顺序是按照模式串下标从小到大。</p>
<p><img src="/01_07.png"></p>
<p>逐位比较，不匹配就移一位；直到主串有一个字符与模式串的第一个字符相同为止。</p>
<p><img src="/01_08.png"></p>
<p>已知空格与”D”不匹配时，前面<code>6</code>个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符”B”对应的”部分匹配值”为<code>2</code>，因此按照规律<code>移动位数 = 已匹配的字符数 - 对应的部分匹配值</code>算出向后移动的位数：<code>6 - 2</code> 等于<code>4</code>，所以将搜索词向后移动<code>4</code>位。</p>
<p><img src="/01_09.png"></p>
<p>因为空格与”C”不匹配，搜索词还要继续往后移。这时，已匹配的字符数为<code>2</code>（”AB”），对应的”部分匹配值”为<code>0</code>。所以，<code>移动位数 = 2 - 0</code>，于是将搜索词向后移<code>2</code>位。<br>按照规律<code>移动位数 = 已匹配的字符数 - 对应的部分匹配值</code>算出向后移动的位数：<code>2 - 0</code> 等于<code>2</code>，所以将搜索词向后移动<code>2</code>位。<br>继续逐位比较，因为空格与”A”不匹配，继续后移<code>1</code>位。</p>
<p><img src="/01_10.png"></p>
<p>逐位比较，直到发现”C”与”D”不匹配。于是，<code>移动位数 = 6 - 2</code>，继续将搜索词向后移动<code>4</code>位。<br>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。</p>
<h4 id="3-1-KMP-算法总结"><a href="#3-1-KMP-算法总结" class="headerlink" title="3.1 KMP 算法总结"></a>3.1 KMP 算法总结</h4><p><code>KMP 算法</code>（Knuth Morris Pratt）的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个<code>next()</code>函数实现，函数本身包含了模式串的局部匹配信息。<code>KMP 算法</code>的时间复杂度<code>O(m+n)</code>。</p>
<h4 id="3-2-KMP-算法的JAVA-代码实现"><a href="#3-2-KMP-算法的JAVA-代码实现" class="headerlink" title="3.2 KMP 算法的JAVA 代码实现"></a>3.2 KMP 算法的JAVA 代码实现</h4><p><strong>部分匹配值</strong>是模式串中子串”前缀”和”后缀”的<strong>最长</strong>的共有元素的长度。<br>《部分匹配表》在代码中定义为 <strong>next 数组</strong>，很多书中也叫<strong>失效函数</strong>（failure function）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现next()函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] kmpNext(String pattern)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    <span class="comment">// 声明部分匹配表数组 next，用于存储部分匹配值</span></span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">    <span class="comment">// 第一个字符没有前后缀，最长匹配值为 0</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环模式串，计算部分匹配表，i初始化为 1</span></span><br><span class="line">    <span class="comment">// j用于记录部分匹配值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>,j = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="comment">// ④ 在0~i中，j&gt;0 并且 pattern.charAt(j) != pattern.charAt(i)时，</span></span><br><span class="line">        <span class="comment">//   表示上一轮比较，前后缀部分匹配值为j。</span></span><br><span class="line">        <span class="comment">//   上一轮比较时，下标[0~j-1]是前后缀最长相同字符串。</span></span><br><span class="line">        <span class="comment">//   下标[j-1]的部分匹配值表示为next[j-1]，即j=next[j-1];</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; pattern.charAt(j) != pattern.charAt(i))&#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ① 在0~i中，j=0 并且 pattern.charAt(j) != pattern.charAt(i)时，</span></span><br><span class="line">        <span class="comment">//   表示前后缀字符串集合中没有相同字符串，next[i]=j（同next[i]=0）</span></span><br><span class="line">        <span class="comment">// ② 在0~i中，j=0 并且 pattern.charAt(j) == pattern.charAt(i)时，</span></span><br><span class="line">        <span class="comment">//   表示前后缀字符串集合中有 1 个相同字符串，j++;next[i]=j;（同next[i]=1）</span></span><br><span class="line">        <span class="comment">// ③ 在0~i中，j&gt;0 并且 pattern.charAt(j) == pattern.charAt(i)时，</span></span><br><span class="line">        <span class="comment">//   表示上一轮比较，前后缀部分匹配值为j。这轮为j+1。因此j++;next[i]=j;</span></span><br><span class="line">        <span class="keyword">if</span>(pattern.charAt(i) == pattern.charAt(j))&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>KMP 算法</code>的框架代码，比较模式串和主串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">kmp</span><span class="params">(String text, String pattern)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123; <span class="keyword">return</span> -<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="comment">// 计算出部分匹配表</span></span><br><span class="line">    <span class="type">int</span>[] next = kmpNext(pattern);</span><br><span class="line">    <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= m-<span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text.charAt(i+j) != pattern.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// j为已匹配的字符串下一个字符的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 后移位数 = 已匹配的字符数j - 对应的部分匹配值next[j-1]</span></span><br><span class="line">            s = j - next[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        i += s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-BM-算法"><a href="#4-BM-算法" class="headerlink" title="4. BM 算法"></a>4. BM 算法</h3><p>BM（Boyer-Moore）算法，也是以两位发明者名字命名的字符串匹配算法。<code>BM 算法</code>不仅效率高，而且构思巧妙，容易理解。</p>
<p><code>BM 算法</code>的核心思想：<br>我们把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。</p>
<p>BM 算法包含两部分，分别是<strong>坏字符</strong>规则（bad character rule）和<strong>好后缀</strong>规则（good suffix shift）。</p>
<h4 id="4-1-坏字符规则"><a href="#4-1-坏字符规则" class="headerlink" title="4.1 坏字符规则"></a>4.1 坏字符规则</h4><p><code>BM 算法</code>的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的。<br>当发现某个字符没法匹配的时候，我们把这个没有匹配的字符叫作”<strong>坏字符</strong>“（bad character）。</p>
<p><img src="/01_03.png"><br>如上图，从尾部开始比较，发现”S”与”E”不匹配，所以”S”就是”坏字符”。<br>并且，”S”不包含在模式串”EXAMPLE”之中，也就是说，可以把模式串直接移到”S”的后一位。</p>
<p><img src="/01_04.png"><br>如上图，依然从尾部开始比较，发现”P”与”E”不匹配，所以”P”是”坏字符”。<br>但是，”P”包含在模式串”EXAMPLE”之中。所以，将模式串后移两位，两个”P”对齐。</p>
<p>由此我们总结出<strong>坏字符规则</strong>：</p>
<blockquote>
<p>后移位数 &#x3D; 坏字符(对应模式串)的位置 - 模式串中的上一次出现位置</p>
<p>（如果”坏字符”不包含在模式串中，则上一次出现位置为 <code>-1</code>）</p>
</blockquote>
<p>如上图，”P”作为”坏字符”为例，出现在模式串的第6位（从0开始编号），在模式串中的上一次出现位置为4，所以后移<code>6 - 4 = 2</code> 位。<br>再以前面”坏字符”的”S”为例，它出现在第6位，上一次出现位置是 -1（即未出现），则整个模式串后移 <code>6 - (-1) = 7</code> 位。</p>
<h4 id="4-2-好后缀规则"><a href="#4-2-好后缀规则" class="headerlink" title="4.2 好后缀规则"></a>4.2 好后缀规则</h4><p>好后缀规则实际上跟坏字符规则的思路很类似。<br>从尾部开始比较，我们把所有尾部匹配的字符串称为”<strong>好后缀</strong>“（good suffix）。</p>
<p><img src="/01_05.png"><br>如上图，从尾部开始比较，”E”与”E”匹配；”LE”与”LE”匹配；”PLE”与”PLE”匹配；”MPLE”与”MPLE”匹配。<br>所以，”MPLE”、”PLE”、”LE”、”E”都是好后缀。<br>比较前一位，发现”I”与”A”不匹配。所以，”I”是”坏字符”。</p>
<p><strong>好后缀规则</strong>：</p>
<blockquote>
<p>后移位数 &#x3D; 好后缀的位置 - 模式串中的上一次出现位置</p>
</blockquote>
<p>举例来说，<br>如果模式串”ABCDAB”的后一个”AB”是”好后缀”。那么<em>好后缀的位置</em>是 <code>5</code>（取最后的”B”的值），<em>模式串中的上一次出现位置</em>是 <code>1</code>（第一个”B”的位置），所以后移<code>5 - 1 = 4</code>位。<br>如果模式串”ABCDEF”的”EF”是好后缀，则<em>好后缀的位置</em>是<code>5</code> ，<em>上一次出现的位置</em>是<code>-1</code>（即未出现），所以后移<code>5 - (-1) = 6</code>位。</p>
<ul>
<li>好后缀规则三个注意点：<ol>
<li>“好后缀”的位置以最后一个字符为准。<ul>
<li>假定”ABCDEF”的”EF”是好后缀，则它的位置以”F”为准，即5。</li>
</ul>
</li>
<li>如果”好后缀”在搜索词中只出现一次，则它的上一次出现位置为 -1。<ul>
<li>比如，”EF”在”ABCDEF”之中只出现一次，则它的上一次出现位置为-1（即未出现）。</li>
</ul>
</li>
<li>如果”好后缀”有多个，则除了最长的那个”好后缀”，其他”好后缀”的上一次出现位置必须在头部。<ul>
<li>比如，假定”BABCDAB”的”好后缀”是”DAB”、”AB”、”B”，此时计算上一次出现位置是第0位，采用好后缀”B”计算。这个规则也可以这样表达：如果最长的那个”好后缀”只出现一次，则可以把搜索词改写成如下形式进行位置计算”(DA)BABCDAB”，即虚拟加入最前面的”DA”。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>回到上图的例子。此时，所有的”好后缀”（MPLE、PLE、LE、E）之中，只有”E”在”EXAMPLE”还出现在头部，所以好后缀规则是后移<code>6 - 0 = 6</code>位。<br>而”I”是”坏字符”，坏字符规则后移<code>2 - (-1) = 3</code>位。<br>可以看到，”坏字符规则”只能移3位，”好后缀规则”可以移6位。所以，<code>BM 算法</code>的基本思想是，<strong>每次后移这两个规则之中的较大值</strong>。</p>
<p>更巧妙的是，这两个规则的移动位数，只与搜索词有关，与原字符串无关。因此，可以预先计算生成《坏字符规则表》和《好后缀规则表》。使用时，只要查表比较一下就可以了。</p>
<p><img src="/01_06.png"><br>继续从尾部开始比较，”P”与”E”不匹配，因此”P”是”坏字符”。根据”坏字符规则”，后移 <code>6 - 4 = 2</code>位；<br>从尾部开始逐位比较，发现全部匹配，于是搜索结束。</p>
<h4 id="4-3-BM-算法总结"><a href="#4-3-BM-算法总结" class="headerlink" title="4.3 BM 算法总结"></a>4.3 BM 算法总结</h4><p><code>BM 算法</code>（Boyer-Moore）核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。<code>BM 算法</code>构建的规则有两类，坏字符规则和好后缀规则。</p>
<h4 id="4-4-BM-算法的JAVA-代码实现"><a href="#4-4-BM-算法的JAVA-代码实现" class="headerlink" title="4.4 BM 算法的JAVA 代码实现"></a>4.4 BM 算法的JAVA 代码实现</h4><p><code>BM 算法</code>的框架代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bm</span><span class="params">(String text, String pattern)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123; <span class="keyword">return</span> -<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="comment">// 计算 坏字符规则表，记录模式串中每个字符最后出现的位置</span></span><br><span class="line">    Map&lt;Character, Integer&gt; badCharRules = generateBadCharRules(pattern);</span><br><span class="line">    <span class="comment">// 计算 好后缀规则表，记录好后缀位置对应后移的位数</span></span><br><span class="line">    <span class="type">int</span>[] goodSuffixRules = generateGoodSuffix(pattern.toCharArray());</span><br><span class="line">    <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">        <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text.charAt(i+j) != pattern.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后移位数 = 坏字符(对应模式串)的位置 - 坏字符在模式串中最后出现位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> j - getBadCharPosition(badCharRules, text.charAt(i + j));</span><br><span class="line">        <span class="comment">// 好后缀后移位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> goodSuffixRules[j];</span><br><span class="line">        <span class="comment">//后移这两个规则之中的较大值</span></span><br><span class="line">        i += Math.max(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-4-1-坏字符规则表"><a href="#4-4-1-坏字符规则表" class="headerlink" title="4.4.1 坏字符规则表"></a>4.4.1 坏字符规则表</h5><p>计算模式串中每个字符最后出现的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 坏字符规则表</span></span><br><span class="line"><span class="comment"> * 记录模式串中每个字符最后出现的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Character, Integer&gt; <span class="title function_">generateBadCharRules</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; bmBc = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(pattern.length());</span><br><span class="line">    <span class="comment">// 选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; pattern.length(); j++) &#123;</span><br><span class="line">        bmBc.put(pattern.charAt(j), j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bmBc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取坏字符在模式串中最后出现位置</span></span><br><span class="line"><span class="comment"> * 未出现返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getBadCharPosition</span><span class="params">(Map&lt;Character, Integer&gt; badChar, Character c)</span>&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> badChar.get(c);</span><br><span class="line">    <span class="keyword">return</span> a == <span class="literal">null</span> ? -<span class="number">1</span> : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-4-2-好后缀规则表"><a href="#4-4-2-好后缀规则表" class="headerlink" title="4.4.2 好后缀规则表"></a>4.4.2 好后缀规则表</h5><p>好后缀规则表，用来记录好后缀位置对应后移的位数。<br>为了实现好后缀规则，需要定义一个<code>suffix</code>数组，用来记录模式串中匹配上好后缀的子串长度。<br>其中，<code>suffix[i] = s</code>满足<code>pattern[i-s,i] == pattern[m-1-s,m-1]</code>，<code>m</code>是模式串的长度。如下图：<code>pattern[i-4,i]</code>和<code>pattern[m-5,m-1]</code>字符相同。<br><img src="/01_11.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算后缀长度数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] getSuffix(<span class="type">char</span>[] pattern)&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length;</span><br><span class="line">    <span class="type">int</span>[] suffix = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">    <span class="comment">// 计算</span></span><br><span class="line">    suffix[m-<span class="number">1</span>] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m-<span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (q &gt;= <span class="number">0</span> &amp;&amp; pattern[q] == pattern[q+m-<span class="number">1</span>-i])&#123;</span><br><span class="line">            q--;</span><br><span class="line">        &#125;</span><br><span class="line">        suffix[i] = i-q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回后缀长度数组</span></span><br><span class="line">    <span class="keyword">return</span> suffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了<code>suffix</code>数组，就可以定义好后缀忽略映射<code>bmgs</code>数组。<br><code>suffix[i]</code>表示模式串中匹配上好后缀的子串长度（<code>i</code>表示子串的末位置）；<br><code>bmgs[j]</code>表示好后缀位置对应后移的位数（<code>j</code>表示好后缀前一个字符的位置，即坏字符的位置）。<br>根据<strong>好后缀规则</strong>：<code>后移位数 = 好后缀的位置 - 模式串中的上一次出现位置</code>，构建<code>bmgs</code>数组分为三种情况：</p>
<ul>
<li>①模式串没有子串匹配上好后缀，也没有最大前缀。<ul>
<li>后移位数为<code>m-1-(-1)</code>，即<code>bmgs[j]=m</code>。</li>
</ul>
</li>
<li>②模式串没有子串匹配上好后缀，但有最大前缀。<ul>
<li>后移位数为<code>m-1-i</code>，即<code>bmgs[j] = m-1-i</code>。<br><img src="/01_13.png"></li>
</ul>
</li>
<li>③模式串有子串匹配上好后缀。<ul>
<li>后移位数为<code>m-1-i</code>，即<code>bmgs[j] = m-1-i; j=m-1-suffix[i]</code>。<br><img src="/01_12.png"></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 好后缀忽略映射（后移位数数组）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] generateGoodSuffix(<span class="type">char</span>[] pattern)&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length;</span><br><span class="line">    <span class="type">int</span>[] bmgs = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">    <span class="comment">// 获取后缀长度数组</span></span><br><span class="line">    <span class="type">int</span>[] suffix = getSuffix(pattern);</span><br><span class="line">    <span class="comment">// 赋值默认值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        bmgs[j] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模式串没有没有子串匹配上好后缀，但有最大前缀</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m-<span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suffix[i] == i+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; m-<span class="number">1</span>-i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(bmgs[j] == m)&#123;</span><br><span class="line">                    bmgs[j] = m-<span class="number">1</span>-i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模式串有子串匹配上好后缀（多个取最左）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m-<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        bmgs[m-<span class="number">1</span>-suffix[i]] = m-<span class="number">1</span>-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回忽略数组</span></span><br><span class="line">    <span class="keyword">return</span> bmgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/25/data-structure-text-pattern-algorithm/" data-id="clrm0oz5z002bebn9dxit8ulv" data-title="「数据结构与算法」单模式字符串匹配算法（BF、RK、KMP、BM）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/06/data-structure-trie-ac/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          「数据结构与算法」Trie 树 与 AC 自动机
        
      </div>
    </a>
  
  
    <a href="/2022/06/02/data-structure-binary-search/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">「数据结构与算法」二分查找</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS3/">CSS3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Canvas/">Canvas</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cron/">Cron</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ElasticStack/">ElasticStack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo%E5%8D%9A%E5%AE%A2/">Hexo博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Interview/">Interview</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%95%99%E7%A8%8B/">Java教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MongoDB/">MongoDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringReactive/">SpringReactive</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebRTC/">WebRTC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/PWA/">PWA</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/rust/">rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shadowsocks/">shadowsocks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/">安全认证</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BlueLake/" rel="tag">BlueLake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas/" rel="tag">Canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CentOS/" rel="tag">CentOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Config/" rel="tag">Config</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cron/" rel="tag">Cron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticStack/" rel="tag">ElasticStack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eureka/" rel="tag">Eureka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FastDFS/" rel="tag">FastDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Function/" rel="tag">Function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gateway/" rel="tag">Gateway</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gogs/" rel="tag">Gogs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/" rel="tag">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/" rel="tag">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/" rel="tag">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Js%E6%A1%86%E6%9E%B6/" rel="tag">Js框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kibana/" rel="tag">Kibana</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LogStash/" rel="tag">LogStash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/" rel="tag">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac-OS/" rel="tag">Mac OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/" rel="tag">Markdown语法规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/" rel="tag">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NFS/" rel="tag">NFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nexus/" rel="tag">Nexus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/" rel="tag">NoSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJs/" rel="tag">NodeJs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenFeign/" rel="tag">OpenFeign</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWA/" rel="tag">PWA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Permissions/" rel="tag">Permissions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RBAC/" rel="tag">RBAC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSE/" rel="tag">SSE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVN/" rel="tag">SVN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sentinel/" rel="tag">Sentinel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/" rel="tag">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringReactive/" rel="tag">SpringReactive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringSecurity/" rel="tag">SpringSecurity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thymeleaf/" rel="tag">Thymeleaf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Token/" rel="tag">Token</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat9/" rel="tag">Tomcat9</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebClient/" rel="tag">WebClient</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebFlux/" rel="tag">WebFlux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YApi/" rel="tag">YApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adb/" rel="tag">adb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adb%E5%91%BD%E4%BB%A4/" rel="tag">adb命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bower/" rel="tag">bower</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/comment/" rel="tag">comment</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/houyi1121/" rel="tag">houyi1121</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" rel="tag">js构造函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">js面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/" rel="tag">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pm2/" rel="tag">pm2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rust/" rel="tag">rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shadowsocks/" rel="tag">shadowsocks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/" rel="tag">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yarn/" rel="tag">yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/" rel="tag">伪元素</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%AA%E7%B1%BB/" rel="tag">伪类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B/" rel="tag">原型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" rel="tag">原型的基本概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="tag">原型链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%94%9FJs/" rel="tag">原生Js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">后端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/" rel="tag">安全认证</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%82%E7%AD%89/" rel="tag">幂等</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8%E6%B0%B4%E6%96%87/" rel="tag">日常水文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A2%A6%E9%AD%87/" rel="tag">梦魇</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A2%A6%E9%AD%87%E5%B0%8F%E6%A0%88/" rel="tag">梦魇小栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="tag">环境配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%BB%E5%B8%83/" rel="tag">画布</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" rel="tag">科学上网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF/" rel="tag">继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" rel="tag">继承的实现方式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" rel="tag">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10.59px;">Android</a> <a href="/tags/BlueLake/" style="font-size: 10.59px;">BlueLake</a> <a href="/tags/Canvas/" style="font-size: 11.18px;">Canvas</a> <a href="/tags/CentOS/" style="font-size: 15.29px;">CentOS</a> <a href="/tags/Config/" style="font-size: 10px;">Config</a> <a href="/tags/Cron/" style="font-size: 10.59px;">Cron</a> <a href="/tags/Docker/" style="font-size: 10.59px;">Docker</a> <a href="/tags/ElasticSearch/" style="font-size: 11.76px;">ElasticSearch</a> <a href="/tags/ElasticStack/" style="font-size: 11.76px;">ElasticStack</a> <a href="/tags/Eureka/" style="font-size: 10px;">Eureka</a> <a href="/tags/FastDFS/" style="font-size: 11.18px;">FastDFS</a> <a href="/tags/Function/" style="font-size: 10.59px;">Function</a> <a href="/tags/Gateway/" style="font-size: 10px;">Gateway</a> <a href="/tags/Git/" style="font-size: 10.59px;">Git</a> <a href="/tags/Gogs/" style="font-size: 10px;">Gogs</a> <a href="/tags/HTML5/" style="font-size: 11.18px;">HTML5</a> <a href="/tags/JQuery/" style="font-size: 13.53px;">JQuery</a> <a href="/tags/JVM/" style="font-size: 11.18px;">JVM</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Java/" style="font-size: 15.88px;">Java</a> <a href="/tags/Javascript/" style="font-size: 10px;">Javascript</a> <a href="/tags/Jenkins/" style="font-size: 11.76px;">Jenkins</a> <a href="/tags/Js%E6%A1%86%E6%9E%B6/" style="font-size: 13.53px;">Js框架</a> <a href="/tags/Kibana/" style="font-size: 11.76px;">Kibana</a> <a href="/tags/Linux/" style="font-size: 17.65px;">Linux</a> <a href="/tags/LogStash/" style="font-size: 11.76px;">LogStash</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Mac-OS/" style="font-size: 10px;">Mac OS</a> <a href="/tags/Markdown%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/" style="font-size: 10px;">Markdown语法规范</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MongoDB/" style="font-size: 10.59px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 13.53px;">MySQL</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/Nexus/" style="font-size: 10px;">Nexus</a> <a href="/tags/Nginx/" style="font-size: 10.59px;">Nginx</a> <a href="/tags/NoSQL/" style="font-size: 11.18px;">NoSQL</a> <a href="/tags/Node/" style="font-size: 12.94px;">Node</a> <a href="/tags/NodeJs/" style="font-size: 11.76px;">NodeJs</a> <a href="/tags/OpenFeign/" style="font-size: 10px;">OpenFeign</a> <a href="/tags/PWA/" style="font-size: 10px;">PWA</a> <a href="/tags/Permissions/" style="font-size: 10px;">Permissions</a> <a href="/tags/RBAC/" style="font-size: 10px;">RBAC</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/Redis/" style="font-size: 13.53px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 10.59px;">RocketMQ</a> <a href="/tags/SSE/" style="font-size: 10px;">SSE</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/Sentinel/" style="font-size: 10px;">Sentinel</a> <a href="/tags/Shell/" style="font-size: 12.35px;">Shell</a> <a href="/tags/Spring/" style="font-size: 18.82px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 13.53px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 12.35px;">SpringCloud</a> <a href="/tags/SpringReactive/" style="font-size: 12.94px;">SpringReactive</a> <a href="/tags/SpringSecurity/" style="font-size: 13.53px;">SpringSecurity</a> <a href="/tags/Thymeleaf/" style="font-size: 10px;">Thymeleaf</a> <a href="/tags/Token/" style="font-size: 10px;">Token</a> <a href="/tags/Tomcat9/" style="font-size: 10px;">Tomcat9</a> <a href="/tags/Ubuntu/" style="font-size: 12.35px;">Ubuntu</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/WebClient/" style="font-size: 10px;">WebClient</a> <a href="/tags/WebFlux/" style="font-size: 10px;">WebFlux</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/YApi/" style="font-size: 10px;">YApi</a> <a href="/tags/adb/" style="font-size: 10.59px;">adb</a> <a href="/tags/adb%E5%91%BD%E4%BB%A4/" style="font-size: 10.59px;">adb命令</a> <a href="/tags/bower/" style="font-size: 10px;">bower</a> <a href="/tags/comment/" style="font-size: 11.18px;">comment</a> <a href="/tags/hexo/" style="font-size: 12.35px;">hexo</a> <a href="/tags/houyi1121/" style="font-size: 10px;">houyi1121</a> <a href="/tags/java/" style="font-size: 14.71px;">java</a> <a href="/tags/javascript/" style="font-size: 17.06px;">javascript</a> <a href="/tags/js%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" style="font-size: 10px;">js构造函数</a> <a href="/tags/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">js面向对象</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/npm/" style="font-size: 11.18px;">npm</a> <a href="/tags/pm2/" style="font-size: 10px;">pm2</a> <a href="/tags/rust/" style="font-size: 10px;">rust</a> <a href="/tags/shadowsocks/" style="font-size: 10px;">shadowsocks</a> <a href="/tags/shell/" style="font-size: 12.94px;">shell</a> <a href="/tags/tools/" style="font-size: 10.59px;">tools</a> <a href="/tags/yarn/" style="font-size: 10px;">yarn</a> <a href="/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/" style="font-size: 10px;">伪元素</a> <a href="/tags/%E4%BC%AA%E7%B1%BB/" style="font-size: 10px;">伪类</a> <a href="/tags/%E5%8E%9F%E5%9E%8B/" style="font-size: 10px;">原型</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">原型的基本概念</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/" style="font-size: 10px;">原型链</a> <a href="/tags/%E5%8E%9F%E7%94%9FJs/" style="font-size: 14.12px;">原生Js</a> <a href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 20px;">后端开发</a> <a href="/tags/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/" style="font-size: 16.47px;">安全认证</a> <a href="/tags/%E5%B9%82%E7%AD%89/" style="font-size: 10px;">幂等</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.76px;">并发编程</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 14.12px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 18.24px;">数据结构</a> <a href="/tags/%E6%97%A5%E5%B8%B8%E6%B0%B4%E6%96%87/" style="font-size: 10px;">日常水文</a> <a href="/tags/%E6%A2%A6%E9%AD%87/" style="font-size: 10px;">梦魇</a> <a href="/tags/%E6%A2%A6%E9%AD%87%E5%B0%8F%E6%A0%88/" style="font-size: 10px;">梦魇小栈</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 19.41px;">环境配置</a> <a href="/tags/%E7%94%BB%E5%B8%83/" style="font-size: 11.18px;">画布</a> <a href="/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" style="font-size: 10px;">科学上网</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 17.65px;">算法</a> <a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 10px;">继承</a> <a href="/tags/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" style="font-size: 10px;">继承的实现方式</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">网络协议</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/17/rust-wechat-game-ylgy/">《羊了个羊》程序员过关攻略</a>
          </li>
        
          <li>
            <a href="/2022/08/15/data-structure-b-tree/">「数据结构与算法」B 树 与 B+ 树</a>
          </li>
        
          <li>
            <a href="/2022/07/25/data-structure-algorithm-method/">「数据结构与算法」常见算法思想</a>
          </li>
        
          <li>
            <a href="/2022/07/06/data-structure-trie-ac/">「数据结构与算法」Trie 树 与 AC 自动机</a>
          </li>
        
          <li>
            <a href="/2022/06/25/data-structure-text-pattern-algorithm/">「数据结构与算法」单模式字符串匹配算法（BF、RK、KMP、BM）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>